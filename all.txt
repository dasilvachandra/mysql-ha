
====================== ./LICENSE ======================
MIT License


====================== ./README.md ======================
📦 mysql-ha

Cluster **MySQL + Zabbix High Availability** lintas Data Center menggunakan **WireGuard VPN** dan **Keepalived VIP**.  
Proyek ini menyediakan struktur direktori, konfigurasi, dan contoh deployment untuk membangun replikasi MySQL dengan failover otomatis dan integrasi Zabbix HA.

✨ Fitur

- 🔒 **WireGuard VPN** sebagai tunnel antar-DC.  
- 🗄️ **MySQL Group Replication (single-primary)** untuk sinkronisasi data.  
- ⚖️ **Keepalived** di DC1/DC2 sebagai pengelola Virtual IP (VIP).  
- 📊 **Zabbix server & frontend** berjalan di DC1 dan DC2 dengan HA mode.  
- 📂 Struktur direktori modular (dc1/, dc2/, mysql/, zabbix/, docs/).  

📂 Struktur Direktori
mysql-ha/
├── dc1/ # Konfigurasi & compose untuk Data Center 1 (MySQL, Zabbix, Keepalived)
├── dc2/ # Konfigurasi & compose untuk Data Center 2 (MySQL, Zabbix, Keepalived)
├── mysql/ # Konfigurasi MySQL Group Replication & init SQL
├── zabbix/ # Dockerfile & compose Zabbix server + frontend
├── docs/ # Dokumentasi & catatan implementasi


🚀 Tujuan

- Memberikan kerangka kerja (scaffold) untuk eksperimen dan implementasi **MySQL + Zabbix HA** lintas DC.  
- Memisahkan konfigurasi per DC agar mudah dimodifikasi sesuai kebutuhan.  
- Mendukung deployment berbasis Docker Compose maupun integrasi ke sistem produksi.  
- Menjamin ketersediaan layanan monitoring meski salah satu DC down (failover otomatis via

====================== ./db_master_master.sh ======================
#!/usr/bin/env bash
set -euo pipefail

DC="${1:-}"

if [[ -z "$DC" ]]; then
  echo "Usage: $0 <dc1|dc2>"
  exit 1
fi

# Default user/pass (ubah kalau beda)
MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD:-abcdef}"

# Nama container default
MYSQL_CONTAINER="mysql1"
SQL_FILE=""

if [[ "$DC" == "dc1" ]]; then
  SQL_FILE="mysql/dc1.sql"
  MYSQL_CONTAINER="mysql1"
elif [[ "$DC" == "dc2" ]]; then
  SQL_FILE="mysql/dc2.sql"
  MYSQL_CONTAINER="mysql2"
else
  echo "Argumen harus dc1 atau dc2"
  exit 1
fi

if [[ ! -f "$SQL_FILE" ]]; then
  echo "[ERROR] File SQL $SQL_FILE tidak ditemukan!"
  exit 1
fi

echo "[INFO] Menjalankan konfigurasi master-master untuk $DC"

# Kalau container ada, eksekusi via docker, kalau tidak langsung mysql host
if docker ps --format '{{.Names}}' | grep -qx "$MYSQL_CONTAINER"; then
  docker exec -i "$MYSQL_CONTAINER" mysql -uroot -p"$MYSQL_ROOT_PASSWORD" < "$SQL_FILE"
else
  mysql -uroot -p"$MYSQL_ROOT_PASSWORD" < "$SQL_FILE"
fi

echo "[SUCCESS] SQL $SQL_FILE berhasil dijalankan di $DC"


====================== ./dc1/docker-compose.yml ======================

services:
  # =========================
  # MySQL DC1 (10.7.0.4)
  # =========================
  mysql1:
    build:
      context: ../mysql
      dockerfile: Dockerfile
    container_name: mysql1
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: "abcdef"
      TZ: "Asia/Jakarta"
    volumes:
      - /opt/mysql:/var/lib/mysql
      - ../mysql/my.cnf.dc1:/etc/mysql/conf.d/my.cnf:ro
      - ../mysql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    # HANYA expose 3306 (tidak pakai host network)
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD-SHELL", "mysqladmin ping -uroot -p$${MYSQL_ROOT_PASSWORD} --silent"]
      interval: 10s
      timeout: 3s
      retries: 20

====================== ./dc1/keepalived/keepalived.conf ======================
global_defs {
  script_user root
  enable_script_security
}

vrrp_instance VI_DB {
  state BACKUP
  initial_state BACKUP
  interface wg0
  virtual_router_id 51
  priority 200
  advert_int 1
  nopreempt

  authentication {
    auth_type PASS
    auth_pass 1234
  }

  unicast_src_ip 10.7.0.4
  unicast_peer {
    10.7.0.5
  }

  virtual_ipaddress {
    10.7.0.10/32 dev wg0 label wg0:vip
  }

  notify_master "/etc/keepalived/scripts/notify.sh master"
  notify_backup "/etc/keepalived/scripts/notify.sh backup"
  notify_fault  "/etc/keepalived/scripts/notify.sh fault"
}


====================== ./dc1/keepalived/keepalived.service.d/override.conf ======================
[Unit]
After=network-online.target wg-quick@wg0.service
Wants=network-online.target wg-quick@wg0.service

====================== ./dc1/keepalived/scripts/demote_dc1.sql ======================
-- Demote DC1 ke replica mengikuti VIP
SET GLOBAL super_read_only=1;
SET GLOBAL read_only=1;
STOP REPLICA;
RESET REPLICA ALL;
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST           = '10.7.0.10',
  SOURCE_PORT           = 3306,
  SOURCE_USER           = 'rep1',
  SOURCE_PASSWORD       = 'abcdef',
  SOURCE_AUTO_POSITION  = 1,
  GET_SOURCE_PUBLIC_KEY = 1;
START REPLICA;


====================== ./dc1/keepalived/scripts/notify.sh ======================
#!/usr/bin/env bash
set -euo pipefail

TYPE="${1:-}"
LOG="/var/log/keepalived-notify.log"

echo "[$(date '+%F %T')] DC1 VRRP event: $TYPE" >> "$LOG"

case "$TYPE" in
  master)
    # DC1 naik MASTER → arahkan route di hub ke db1
    ssh -o StrictHostKeyChecking=no root@10.7.0.1 -q -T "switch-db-route.sh db1" >> "$LOG" 2>&1
    ;;
  backup)
    echo "[$(date '+%F %T')] DC1 masuk BACKUP (no-op)" >> "$LOG"
    ;;
  fault)
    echo "[$(date '+%F %T')] DC1 fault condition" >> "$LOG"
    ;;
esac


====================== ./dc1/keepalived/scripts/promote_dc1.sql ======================
-- Promote DC1 (writer)
STOP REPLICA;
RESET REPLICA ALL;
SET GLOBAL super_read_only=0;
SET GLOBAL read_only=0;


====================== ./dc2/docker-compose.yml ======================

services:
  # =========================
  # MySQL DC2 (10.7.0.5)
  # =========================
  mysql2:
    build:
      context: ../mysql
      dockerfile: Dockerfile
    container_name: mysql2
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: "abcdef"
      TZ: "Asia/Jakarta"
    volumes:
      - /opt/mysql:/var/lib/mysql
      - ../mysql/my.cnf.dc2:/etc/mysql/conf.d/my.cnf:ro
      - ../mysql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "3306:3306"
    healthcheck:
      test: ["CMD-SHELL", "mysqladmin ping -uroot -p$${MYSQL_ROOT_PASSWORD} --silent"]
      interval: 10s
      timeout: 3s
      retries: 20


====================== ./dc2/keepalived/keepalived.conf ======================
global_defs {
    script_user root
    enable_script_security
}

vrrp_instance VI_1 {
    state BACKUP
    interface wg0
    virtual_router_id 51
    priority 150
    advert_int 1
    initial_state BACKUP
    nopreempt

    authentication {
        auth_type PASS
        auth_pass 1234
    }

    unicast_src_ip 10.7.0.5
    unicast_peer {
        10.7.0.4
    }

    virtual_ipaddress {
        10.7.0.10/32 dev wg0 label wg0:vip
    }

    notify_master "/etc/keepalived/scripts/notify.sh master"
    notify_backup "/etc/keepalived/scripts/notify.sh backup"
    notify_fault  "/etc/keepalived/scripts/notify.sh fault"
}


====================== ./dc2/keepalived/keepalived.service.d/override.conf ======================
global
    log /dev/log local0
    maxconn 4096

defaults
    log global
    mode tcp
    option tcplog
    timeout connect 5s
    timeout client  60s
    timeout server  60s
    retries 3

# =========================
# MySQL via VIP (user/app connect ke 10.7.0.10:3306)
# =========================
frontend mysql_front
    bind 10.7.0.10:3306
    default_backend mysql_local

backend mysql_local
    mode tcp
    option tcp-check
    server localmysql 127.0.0.1:3306 check inter 2s fall 3 rise 2

# =========================
# Zabbix Server (10051) via VIP
# =========================
frontend zabbix_server_front
    bind 10.7.0.10:10051
    default_backend zabbix_server_local

backend zabbix_server_local
    mode tcp
    option tcp-check
    server localzbx 127.0.0.1:10051 check inter 2s fall 3 rise 2

# =========================
# Zabbix Web (8080) via VIP
# =========================
frontend zabbix_web_front
    bind 10.7.0.10:8080
    default_backend zabbix_web_local

backend zabbix_web_local
    mode tcp
    option tcp-check
    server localweb 127.0.0.1:8080 check inter 2s fall 3 rise 2


====================== ./dc2/keepalived/scripts/demote_dc2.sql ======================
-- Demote DC2 ke replica mengikuti VIP
SET GLOBAL super_read_only=1;
SET GLOBAL read_only=1;
STOP REPLICA;
RESET REPLICA ALL;
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST           = '10.7.0.10',
  SOURCE_PORT           = 3306,
  SOURCE_USER           = 'rep1',
  SOURCE_PASSWORD       = 'abcdef',
  SOURCE_AUTO_POSITION  = 1,
  GET_SOURCE_PUBLIC_KEY = 1;
START REPLICA;


====================== ./dc2/keepalived/scripts/notify.sh ======================
#!/usr/bin/env bash
set -euo pipefail

TYPE="${1:-}"
LOG="/var/log/keepalived-notify.log"

echo "[$(date '+%F %T')] DC2 VRRP event: $TYPE" >> "$LOG"

case "$TYPE" in
  master)
    # DC2 naik MASTER → arahkan route di hub ke db2
    ssh -o StrictHostKeyChecking=no root@10.7.0.1 -q -T "switch-db-route.sh db2" >> "$LOG" 2>&1
    ;;
  backup)
    echo "[$(date '+%F %T')] DC2 masuk BACKUP (no-op)" >> "$LOG"
    ;;
  fault)
    echo "[$(date '+%F %T')] DC2 fault condition" >> "$LOG"
    ;;
esac


====================== ./dc2/keepalived/scripts/promote_dc2.sql ======================
-- Promote DC2 (writer)
STOP REPLICA;
RESET REPLICA ALL;
SET GLOBAL super_read_only=0;
SET GLOBAL read_only=0;


====================== ./docs/README.md ======================
# mysql-ha

Cluster **MySQL High Availability + Zabbix HA** lintas Data Center menggunakan **WireGuard VPN** dan **Keepalived VIP**.

## Struktur Direktori
- `dc1/`, `dc2/` → konfigurasi per Data Center (docker-compose untuk MySQL & Zabbix).  
- `mysql/` → konfigurasi MySQL Group Replication.  
- `zabbix/` → konfigurasi Zabbix server & frontend.  
- `docs/` → catatan & dokumentasi bootstrap.  

## Mekanisme HA
- **Database** direplikasi menggunakan **MySQL Group Replication** (single-primary mode) antara DC1 & DC2.  
- **Keepalived** mengelola Virtual IP (**10.7.0.10**) untuk semua layanan:  
  - `10.7.0.10:3306` → MySQL cluster  
  - `10.7.0.10:10051` → Zabbix server  
  - `10.7.0.10:8080` → Zabbix frontend (Web UI)  
- **Failover**: Jika DC1 down, DC2 akan otomatis mengambil alih VIP, begitu juga sebaliknya.  
- **Zabbix Server** berjalan di DC1 & DC2 dengan HA mode (`HANodeName` berbeda, hanya 1 node aktif).  
- **Zabbix Frontend** tersedia di kedua DC, diakses melalui **VIP yang sama**.  

## Catatan
- **WireGuard** harus sudah dikonfigurasi di host (bukan container).  
- Semua container MySQL & Zabbix tetap berjalan di kedua DC.  
- VIP `10.7.0.10` berpindah otomatis antar DC melalui **Keepalived**.  
- Monitoring client (misalnya NMS atau pengguna web) cukup mengakses VIP saja, tanpa perlu tahu node mana yang sedang aktif.  


====================== ./git-pull.sh ======================
#!/bin/bash
# Script otomatis git force pull dengan timestamp log

TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")

echo "🔄 [$TIMESTAMP] Menarik update terbaru (force pull) dari remote..."

# Ambil semua update remote
git fetch --all

# Reset ke remote main (hapus perubahan lokal)
git reset --hard origin/main

echo "✅ [$TIMESTAMP] Force pull selesai (sinkron dengan origin/main)"


====================== ./git-push.sh ======================
#!/usr/bin/env bash
set -euo pipefail

ts="$(date '+%Y-%m-%d %H:%M:%S')"
branch="$(git rev-parse --abbrev-ref HEAD)"

# Ada perubahan?
if [[ -z "$(git status --porcelain=v1)" ]]; then
  echo "✅ Tidak ada perubahan file."
  exit 0
fi

echo "🗂  Staging semua perubahan (termasuk delete/rename)…"
git add -A

# Pastikan memang ada yang staged
if [[ -z "$(git diff --cached --name-only)" ]]; then
  echo "ℹ️  Tidak ada perubahan yang ter-stage."
  exit 0
fi

# Hitung total baris repo (opsional, untuk persentase)
# Aman jika repo besar? Kalau takut lambat, boleh skip bagian ini.
total_lines=$(git ls-files -z | xargs -0 cat 2>/dev/null | wc -l | awk '{print $1}')
[[ -z "$total_lines" ]] && total_lines=0

# Hitung total insert/delete yang AKAN di-commit
read -r ins del <<<"$(git diff --cached --numstat | awk '{a+=$1; b+=$2} END{print (a+0) " " (b+0)}')"
change=$((ins + del))
if (( total_lines > 0 )); then
  percent=$(( 100 * change / total_lines ))
else
  percent=0
fi

msg="update: $ts | +$ins -$del (~$percent%)"
echo "📝 Commit: $msg"
git commit -m "$msg"

echo "🚀 Push ke remote (origin $branch)…"
git push origin "$branch"
echo "✅ Selesai."


====================== ./install-keepalived.sh ======================
#!/usr/bin/env bash
set -euo pipefail

DC="${1:-}"
if [[ -z "$DC" ]]; then
  echo "Usage: $0 <dc1|dc2>"
  exit 1
fi

if [[ "$DC" != "dc1" && "$DC" != "dc2" ]]; then
  echo "Error: Parameter harus dc1 atau dc2"
  exit 1
fi

# Tentukan base path = folder tempat script ini berada
BASE_DIR="$(cd "$(dirname "$0")" && pwd)"
SRC_DIR="$BASE_DIR/$DC/keepalived"

if [[ ! -d "$SRC_DIR" ]]; then
  echo "Error: Direktori $SRC_DIR tidak ditemukan"
  exit 1
fi

echo "[INFO] Install keepalived + mysql-client"
apt update -y
apt install -y keepalived mysql-client

echo "[INFO] Buat direktori konfigurasi"
mkdir -p /etc/keepalived/scripts
mkdir -p /etc/systemd/system/keepalived.service.d

echo "[INFO] Copy konfigurasi keepalived ($DC)"
cp "$SRC_DIR/keepalived.conf" /etc/keepalived/keepalived.conf

echo "[INFO] Copy semua script SQL & bash"
cp "$SRC_DIR/scripts/"*.sh /etc/keepalived/scripts/ 2>/dev/null || true
cp "$SRC_DIR/scripts/"*.sql /etc/keepalived/scripts/ 2>/dev/null || true
chmod +x /etc/keepalived/scripts/*.sh || true

if [[ -f "$SRC_DIR/keepalived.service.d/override.conf" ]]; then
  echo "[INFO] Pasang systemd override (wait WireGuard)"
  cp "$SRC_DIR/keepalived.service.d/override.conf" \
     /etc/systemd/system/keepalived.service.d/override.conf
fi

echo "[INFO] Reload systemd & enable keepalived"
systemctl daemon-reload
systemctl enable keepalived
systemctl restart keepalived

echo "[INFO] Status keepalived:"
systemctl --no-pager --full status keepalived || true

echo "[SUCCESS] Instalasi keepalived untuk $DC selesai."


====================== ./list_files.sh ======================
#!/bin/bash

# Folder atau file yang akan diabaikan (boleh wildcard)
IGNORED_DIRS=(".git" "node_modules" "*.log" "*.txt")

# File output gabungan
OUTPUT_FILE="all.txt"
> "$OUTPUT_FILE" # kosongkan file output

print_tree_and_collect() {
    local dir="$1"
    local prefix="$2"
    local items=("$dir"/*)
    local count=${#items[@]}
    local index=0

    for item in "${items[@]}"; do
        local basename=$(basename "$item")

        # Lewati jika cocok dengan pola di IGNORED_DIRS (mendukung wildcard)
        for ignored in "${IGNORED_DIRS[@]}"; do
            if [[ "$basename" == $ignored ]]; then
                continue 2
            fi
        done

        index=$((index + 1))
        local connector="├──"
        [[ $index -eq $count ]] && connector="└──"

        if [[ -d "$item" ]]; then
            echo "${prefix}${connector} 📁 $basename/"
            print_tree_and_collect "$item" "${prefix}│   "
        elif [[ -f "$item" ]]; then
            echo "${prefix}${connector} 📄 $basename"

            # Tambahkan isi file ke all.txt
            {
                echo ""
                echo "====================== $item ======================"
                cat "$item"
                echo ""
            } >> "$OUTPUT_FILE"
        fi
    done
}

echo "📁 $(basename "$(pwd)")/"
print_tree_and_collect "." "│   "

echo ""
echo "✅ Semua isi file tersimpan ke: $OUTPUT_FILE"


====================== ./mysql/Dockerfile ======================
FROM mysql:8.0.30

LABEL maintainer="Andes Solutions"

# Tambahkan tools troubleshooting
RUN microdnf install -y iputils net-tools iproute dnsutils curl vim traceroute tcpdump && \
    microdnf clean all

CMD ["mysqld"]


====================== ./mysql/dc1.sql ======================
-- Jalankan di DC1 (10.7.0.4)
STOP REPLICA;
RESET REPLICA ALL;

-- Set AUTO_INCREMENT supaya tidak tabrakan ID
SET PERSIST auto_increment_increment = 2;
SET PERSIST auto_increment_offset    = 1;

-- Buat user replikasi (aman jika sudah ada)
CREATE USER IF NOT EXISTS 'rep1'@'%' IDENTIFIED BY 'abcdef';
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'rep1'@'%';
FLUSH PRIVILEGES;

-- Replikasi dari DC2 -> DC1
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST           = '10.7.0.5',
  SOURCE_PORT           = 3306,
  SOURCE_USER           = 'rep1',
  SOURCE_PASSWORD       = 'abcdef',
  SOURCE_AUTO_POSITION  = 1,
  GET_SOURCE_PUBLIC_KEY = 1;

START REPLICA;

SHOW REPLICA STATUS\G


====================== ./mysql/dc2.sql ======================
-- Jalankan di DC2 (10.7.0.5)
STOP REPLICA;
RESET REPLICA ALL;

-- Set AUTO_INCREMENT supaya tidak tabrakan ID
SET PERSIST auto_increment_increment = 2;
SET PERSIST auto_increment_offset    = 2;

-- Buat user replikasi (aman jika sudah ada)
CREATE USER IF NOT EXISTS 'rep1'@'%' IDENTIFIED BY 'abcdef';
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'rep1'@'%';
FLUSH PRIVILEGES;

-- Replikasi dari DC1 -> DC2
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST           = '10.7.0.4',
  SOURCE_PORT           = 3306,
  SOURCE_USER           = 'rep1',
  SOURCE_PASSWORD       = 'abcdef',
  SOURCE_AUTO_POSITION  = 1,
  GET_SOURCE_PUBLIC_KEY = 1;

START REPLICA;

SHOW REPLICA STATUS\G


====================== ./mysql/init.sql ======================
-- ======================================================
-- Init script untuk MySQL HA + Zabbix
-- Akan dijalankan hanya sekali saat container pertama kali dibuat
-- ======================================================

-- 1. Buat user untuk replikasi antar DC
DROP USER IF EXISTS 'rep1'@'%';
CREATE USER 'rep1'@'%' IDENTIFIED BY 'abcdef';
GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'rep1'@'%';

-- 2. Buat database untuk Zabbix
DROP DATABASE IF EXISTS zabbix;
CREATE DATABASE zabbix CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;

-- 3. Buat user untuk Zabbix
DROP USER IF EXISTS 'zabbix'@'%';
CREATE USER 'zabbix'@'%' IDENTIFIED BY 'abcdef';
GRANT ALL PRIVILEGES ON zabbix.* TO 'zabbix'@'%';

-- 4. Commit privilege
FLUSH PRIVILEGES;


====================== ./mysql/my.cnf.dc1 ======================
[mysqld]
# Identity
server_id=1
bind-address=0.0.0.0

# Binary log wajib untuk replikasi
log_bin=binlog
binlog_format=ROW
sync_binlog=1

# GTID (opsional tapi disarankan untuk failover otomatis/manual)
gtid_mode=ON
enforce_gtid_consistency=ON

# Replikasi
relay_log=relay-bin
relay_log_index=relay-bin.index
master_info_repository=TABLE
relay_log_info_repository=TABLE

# Optimasi & keamanan
skip_name_resolve=ON
binlog_checksum=NONE

# Laporan host ke replica
report_host=10.7.0.4
report_port=3306

# Default karakter set
character-set-server=utf8mb4
collation-server=utf8mb4_general_ci


====================== ./mysql/my.cnf.dc2 ======================
[mysqld]
# Identity
server_id=2
bind-address=0.0.0.0

# Binary log tetap diaktifkan agar bisa promote DC2 jadi master jika DC1 down
log_bin=binlog
binlog_format=ROW
sync_binlog=1

# GTID (sama dengan DC1)
gtid_mode=ON
enforce_gtid_consistency=ON

# Relay log (wajib untuk replica)
relay_log=relay-bin
relay_log_index=relay-bin.index
master_info_repository=TABLE
relay_log_info_repository=TABLE

# Optimasi & keamanan
skip_name_resolve=ON
binlog_checksum=NONE

# Laporan host ke source
report_host=10.7.0.5
report_port=3306

# Default karakter set
character-set-server=utf8mb4
collation-server=utf8mb4_general_ci


====================== ./rebuild.sh ======================
#!/usr/bin/env bash
set -euo pipefail

BASE_DIR="$(dirname "$0")"

if [[ $# -eq 0 ]]; then
  echo "❌ Harus ada parameter! Contoh:"
  echo "   ./rebuild.sh dc1"
  echo "   ./rebuild.sh dc2"
  echo "   ./rebuild.sh hub"
  exit 1
fi

TARGET="$1"
TARGET_DIR="$BASE_DIR/$TARGET"

if [[ ! -d "$TARGET_DIR" ]]; then
  echo "❌ Folder $TARGET_DIR tidak ditemukan!"
  exit 2
fi

echo "🚀 Rebuild docker compose untuk: $TARGET"
echo "========================================="

cd "$TARGET_DIR"

echo "🔨 docker compose build..."
docker compose build --no-cache

echo "⬆️ docker compose up -d..."
docker compose up -d

echo "✅ $TARGET selesai"

echo ""
echo "🎉 Service $TARGET berhasil direbuild & dijalankan!"


====================== ./zabbix/Dockerfile.server ======================
# Zabbix Server (MySQL) — pinned to 7.0 alpine
FROM zabbix/zabbix-server-mysql:alpine-7.0-latest


USER root
RUN apk add --no-cache bash tzdata curl mysql-client \
&& cp /usr/share/zoneinfo/Asia/Jakarta /etc/localtime \
&& echo "Asia/Jakarta" > /etc/timezone


# Simple healthcheck: ensure DB reachable and zabbix_server responds
ADD ./healthcheck-server.sh /usr/local/bin/healthcheck-server.sh
RUN chmod +x /usr/local/bin/healthcheck-server.sh


HEALTHCHECK --interval=20s --timeout=10s --retries=6 \
CMD /usr/local/bin/healthcheck-server.sh


# Keep default entrypoint/cmd from upstream

====================== ./zabbix/Dockerfile.web ======================
# Zabbix Web (Nginx + PHP-FPM for MySQL) — pinned to 7.0 alpine
FROM zabbix/zabbix-web-nginx-mysql:alpine-7.0-latest


USER root
RUN apk add --no-cache bash tzdata curl \
&& cp /usr/share/zoneinfo/Asia/Jakarta /etc/localtime \
&& echo "Asia/Jakarta" > /etc/timezone


# Healthcheck: hit local nginx
ADD ./healthcheck-web.sh /usr/local/bin/healthcheck-web.sh
RUN chmod +x /usr/local/bin/healthcheck-web.sh


HEALTHCHECK --interval=20s --timeout=10s --retries=6 \
CMD /usr/local/bin/healthcheck-web.sh

====================== ./zabbix/docker-compose-dc1.yml ======================
services:
  # One-shot init job: import schema/images/data kalau DB masih kosong
  zbx-db-init:
    image: zabbix/zabbix-server-mysql:alpine-7.0-latest
    container_name: zbx-db-init
    environment:
      DB_SERVER_HOST: ${DB_SERVER_HOST}
      DB_SERVER_PORT: ${DB_SERVER_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      TZ: ${TZ}
      FORCE_REIMPORT: ${FORCE_REIMPORT:-0}
    entrypoint: ["/bin/sh","-lc"]
    command: >
      set -e;
      echo "[zbx-db-init] Waiting DB ${DB_SERVER_HOST}:${DB_SERVER_PORT}";
      until mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} -e "SELECT 1" ${MYSQL_DATABASE} >/dev/null 2>&1; do
        sleep 2; echo -n .; done; echo;
      cnt=$$(mysql -N -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD}
        -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='${MYSQL_DATABASE}'");
      echo "[zbx-db-init] Tables in ${MYSQL_DATABASE}: $$cnt";
      if [ "${FORCE_REIMPORT}" = "1" ]; then cnt=0; fi;
      if [ "$$cnt" -lt 10 ]; then
        echo "[zbx-db-init] Importing schema...";
        zcat /usr/share/doc/zabbix-sql-scripts/mysql/schema.sql.gz | \
          mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE};
        echo "[zbx-db-init] Importing images...";
        zcat /usr/share/doc/zabbix-sql-scripts/mysql/images.sql.gz | \
          mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE};
        echo "[zbx-db-init] Importing data...";
        zcat /usr/share/doc/zabbix-sql-scripts/mysql/data.sql.gz | \
          mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE};
        echo "[zbx-db-init] Done.";
      else
        echo "[zbx-db-init] Database already initialized; skip.";
      fi
    restart: "no"
    networks: [zbx_net]

  zabbix-server:
    build:
      context: .
      dockerfile: ./Dockerfile.server
    container_name: zbx-server-dc1
    depends_on:
      - zbx-db-init
    environment:
      DB_SERVER_HOST: ${DB_SERVER_HOST}
      DB_SERVER_PORT: ${DB_SERVER_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      ZBX_DEBUGLEVEL: ${ZBX_DEBUGLEVEL}
      TZ: ${TZ}
    ports:
      - "10051:10051"
    volumes:
      - zbx_srv_data:/var/lib/zabbix
      - zbx_srv_log:/var/log/zabbix
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"
    networks: [zbx_net]

  zabbix-web:
    build:
      context: .
      dockerfile: ./Dockerfile.web
    container_name: zbx-web-dc1
    depends_on:
      - zabbix-server
    environment:
      DB_SERVER_HOST: ${DB_SERVER_HOST}
      DB_SERVER_PORT: ${DB_SERVER_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      ZBX_SERVER_HOST: zabbix-server
      PHP_TZ: ${TZ}
      TZ: ${TZ}
    ports:
      - "${HTTP_PORT}:8080"
    volumes:
      - zbx_web_log:/var/log/nginx
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"
    networks: [zbx_net]

networks:
  zbx_net:
    name: zbx_net

volumes:
  zbx_srv_data:
  zbx_srv_log:
  zbx_web_log:

====================== ./zabbix/docker-compose-dc2.yml ======================
services:
  # One-shot init job: import schema/images/data kalau DB masih kosong
  zbx-db-init:
    image: zabbix/zabbix-server-mysql:alpine-7.0-latest
    container_name: zbx-db-init
    environment:
      DB_SERVER_HOST: ${DB_SERVER_HOST}
      DB_SERVER_PORT: ${DB_SERVER_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      TZ: ${TZ}
      FORCE_REIMPORT: ${FORCE_REIMPORT:-0}
    entrypoint: ["/bin/sh","-lc"]
    command: >
      set -e;
      echo "[zbx-db-init] Waiting DB ${DB_SERVER_HOST}:${DB_SERVER_PORT}";
      until mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} -e "SELECT 1" ${MYSQL_DATABASE} >/dev/null 2>&1; do
        sleep 2; echo -n .; done; echo;
      cnt=$$(mysql -N -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD}
        -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='${MYSQL_DATABASE}'");
      echo "[zbx-db-init] Tables in ${MYSQL_DATABASE}: $$cnt";
      if [ "${FORCE_REIMPORT}" = "1" ]; then cnt=0; fi;
      if [ "$$cnt" -lt 10 ]; then
        echo "[zbx-db-init] Importing schema...";
        zcat /usr/share/doc/zabbix-sql-scripts/mysql/schema.sql.gz | \
          mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE};
        echo "[zbx-db-init] Importing images...";
        zcat /usr/share/doc/zabbix-sql-scripts/mysql/images.sql.gz | \
          mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE};
        echo "[zbx-db-init] Importing data...";
        zcat /usr/share/doc/zabbix-sql-scripts/mysql/data.sql.gz | \
          mysql -h${DB_SERVER_HOST} -P${DB_SERVER_PORT} -u${MYSQL_USER} -p${MYSQL_PASSWORD} ${MYSQL_DATABASE};
        echo "[zbx-db-init] Done.";
      else
        echo "[zbx-db-init] Database already initialized; skip.";
      fi
    restart: "no"
    networks: [zbx_net]

  zabbix-server:
    build:
      context: .
      dockerfile: ./Dockerfile.server
    container_name: zbx-server-dc1
    depends_on:
      - zbx-db-init
    environment:
      DB_SERVER_HOST: ${DB_SERVER_HOST}
      DB_SERVER_PORT: ${DB_SERVER_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      ZBX_DEBUGLEVEL: ${ZBX_DEBUGLEVEL}
      TZ: ${TZ}
    ports:
      - "10051:10051"
    volumes:
      - zbx_srv_data:/var/lib/zabbix
      - zbx_srv_log:/var/log/zabbix
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"
    networks: [zbx_net]

  zabbix-web:
    build:
      context: .
      dockerfile: ./Dockerfile.web
    container_name: zbx-web-dc1
    depends_on:
      - zabbix-server
    environment:
      DB_SERVER_HOST: ${DB_SERVER_HOST}
      DB_SERVER_PORT: ${DB_SERVER_PORT}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      ZBX_SERVER_HOST: zabbix-server
      PHP_TZ: ${TZ}
      TZ: ${TZ}
    ports:
      - "${HTTP_PORT}:8080"
    volumes:
      - zbx_web_log:/var/log/nginx
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"
    networks: [zbx_net]

networks:
  zbx_net:
    name: zbx_net

volumes:
  zbx_srv_data:
  zbx_srv_log:
  zbx_web_log:

====================== ./zabbix/healthcheck-server.sh ======================
#!/usr/bin/env bash
set -euo pipefail
: "${DB_SERVER_HOST:?need DB_SERVER_HOST}"
: "${MYSQL_USER:?need MYSQL_USER}"
: "${MYSQL_PASSWORD:?need MYSQL_PASSWORD}"
: "${MYSQL_DATABASE:=zabbix}"
: "${DB_SERVER_PORT:=3306}"


# 1) DB reachability
if ! mysql -h"${DB_SERVER_HOST}" -P"${DB_SERVER_PORT}" -u"${MYSQL_USER}" -p"${MYSQL_PASSWORD}" -e 'SELECT 1' "${MYSQL_DATABASE}" >/dev/null 2>&1; then
echo "DB not reachable"; exit 1
fi


# 2) zabbix_server process up & can answer version
if ! /usr/sbin/zabbix_server -V >/dev/null 2>&1; then
echo "zabbix_server not responding"; exit 1
fi


echo OK

====================== ./zabbix/healthcheck-web.sh ======================
#!/usr/bin/env bash
set -euo pipefail

# Try to fetch local nginx front page
status=$(curl -s -o /dev/null -w '%{http_code}' http://127.0.0.1:8080/)
[ "$status" = "200" ] || { echo "HTTP $status"; exit 1; }
echo OK

